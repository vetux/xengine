/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2024  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or
 *  modify it under the terms of the GNU Lesser General Public
 *  License as published by the Free Software Foundation; either
 *  version 3 of the License, or (at your option) any later version.

 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 *  Lesser General Public License for more details.

 *  You should have received a copy of the GNU Lesser General Public License
 *  along with this program; if not, write to the Free Software Foundation,
 *  Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
 */

#include "xng/render/graph/passes/wireframepass.hpp"

#include "xng/render/graph/framegraphbuilder.hpp"

#include "xng/render/geometry/vertexstream.hpp"

#include "graph/wireframepass_vs.hpp" // Generated by cmake
#include "graph/wireframepass_fs.hpp" // Generated by cmake

// TODO: Verify / Report GCC (GNU 12.2.0) bug: When two .cpp files define a struct with the same name but different members the compiler seems to emit undefined behaviour / memory corruption.

namespace xng {
#pragma pack(push, 1)
    struct ShaderDrawDataWireframe {
        Mat4f model;
        Mat4f mvp;
        int objectID_boneOffset[4]{0, 0, 0, 0};
        float wireColor[4]{0, 0, 0, 0};
    };
#pragma pack(pop)

    void WireframePass::setup(FrameGraphBuilder &builder) {
        auto resolution = builder.getRenderResolution();

        if (!renderPipeline.assigned) {
            renderPipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {{VERTEX,   wireframepass_vs},
                                {FRAGMENT, wireframepass_fs}},
                    .bindings = {
                            BIND_SHADER_STORAGE_BUFFER,
                            BIND_SHADER_STORAGE_BUFFER,
                    },
                    .primitive = LINES,
                    .vertexLayout = SkinnedMesh::getDefaultVertexLayout(),
                    .enableDepthTest = true,
                    .depthTestWrite = true,
                    .depthTestMode = DEPTH_TEST_LESS,
                    .enableBlending = true,
            });
        }

        builder.persist(renderPipeline);

        std::vector<Node> objects;
        size_t totalShaderBufferSize = 0;

        std::set<Uri> usedMeshes;

        size_t boneCount = 0;

        auto tmp = builder.getScene().rootNode.findAll({typeid(SkinnedMeshProperty)});
        for (auto id = 0; id < tmp.size(); id++) {
            auto &object = tmp.at(id);
            auto &meshProp = object.getProperty<SkinnedMeshProperty>();
            if (meshProp.mesh.assigned()) {
                meshAllocator.prepareMeshAllocation(meshProp.mesh);
                usedMeshes.insert(meshProp.mesh.getUri());

                for (auto i = 0; i < meshProp.mesh.get().subMeshes.size() + 1; i++) {
                    const Mesh &mesh = i == 0 ? meshProp.mesh.get() : meshProp.mesh.get().subMeshes.at(i - 1);

                    boneCount += mesh.bones.size();

                    totalShaderBufferSize += sizeof(ShaderDrawDataWireframe);
                }
                objects.emplace_back(object);
            }
        }

        auto shaderBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .bufferType = RenderBufferType::HOST_VISIBLE,
                .size = totalShaderBufferSize
        });

        auto boneBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .bufferType = RenderBufferType::HOST_VISIBLE,
                .size = sizeof(Mat4f) * boneCount
        });

        if (vertexBuffer.assigned) {
            builder.persist(vertexBuffer);
        }

        if (indexBuffer.assigned) {
            builder.persist(indexBuffer);
        }

        if (!vertexBuffer.assigned || currentVertexBufferSize < meshAllocator.getRequestedVertexBufferSize()) {
            auto staleVertexBuffer = vertexBuffer;
            auto d = VertexBufferDesc();
            d.size = meshAllocator.getRequestedVertexBufferSize();
            vertexBuffer = builder.createVertexBuffer(d);
            builder.persist(vertexBuffer);
            if (staleVertexBuffer.assigned)
                builder.copy(staleVertexBuffer, vertexBuffer, 0, 0, currentVertexBufferSize);
            currentVertexBufferSize = d.size;
        }

        if (!indexBuffer.assigned || currentIndexBufferSize < meshAllocator.getRequestedIndexBufferSize()) {
            auto staleIndexBuffer = indexBuffer;
            auto d = IndexBufferDesc();
            d.size = meshAllocator.getRequestedIndexBufferSize();
            indexBuffer = builder.createIndexBuffer(d);
            builder.persist(indexBuffer);
            if (staleIndexBuffer.assigned)
                builder.copy(staleIndexBuffer, indexBuffer, 0, 0, currentIndexBufferSize);
            currentIndexBufferSize = d.size;
        }

        meshAllocator.uploadMeshes(builder, vertexBuffer, indexBuffer);

        auto cameraNode = builder.getScene().rootNode.find<CameraProperty>();
        auto camera = cameraNode.getProperty<CameraProperty>().camera;
        auto cameraTransform = cameraNode.getProperty<TransformProperty>().transform;

        // Deallocate unused meshes
        std::set<Uri> dealloc;
        for (auto &pair: meshAllocator.getMeshAllocations()) {
            if (usedMeshes.find(pair.first) == usedMeshes.end()) {
                dealloc.insert(pair.first);
            }
        }
        for (auto &uri: dealloc) {
            meshAllocator.deallocateMesh(ResourceHandle<SkinnedMesh>(uri));
        }

        // Draw wireframe
        auto projection = camera.projection();
        auto view = Camera::view(cameraTransform);

        auto screenColor = builder.getSlot(SLOT_SCREEN_COLOR);
        auto screenDepth = builder.getSlot(SLOT_SCREEN_DEPTH);

        std::vector<DrawCall> drawCalls;
        std::vector<size_t> baseVertices;
        std::vector<ShaderDrawDataWireframe> shaderData;
        std::vector<Mat4f> boneMatrices;

        for (auto oi = 0; oi < objects.size(); oi++) {
            auto &node = objects.at(oi);
            auto &meshProp = node.getProperty<SkinnedMeshProperty>();

            auto rig = meshProp.mesh.get().rig;

            std::map<std::string, Mat4f> boneTransforms;
            auto it = node.properties.find(typeid(BoneTransformsProperty));
            if (it != node.properties.end()) {
                boneTransforms = it->second->get<BoneTransformsProperty>().boneTransforms;
            }

            auto drawData = meshAllocator.getAllocatedMesh(meshProp.mesh);

            for (auto i = 0; i < meshProp.mesh.get().subMeshes.size() + 1; i++) {
                auto model = node.getProperty<TransformProperty>().transform.model();

                const Mesh &mesh = i == 0 ? meshProp.mesh.get() : meshProp.mesh.get().subMeshes.at(i - 1);

                auto boneOffset = boneMatrices.size();
                if (mesh.bones.empty()) {
                    boneOffset = -1;
                } else {
                    for (auto &bone: mesh.bones) {
                        auto bt = boneTransforms.find(bone);
                        if (bt != boneTransforms.end()) {
                            boneMatrices.emplace_back(bt->second);
                        } else {
                            boneMatrices.emplace_back(MatrixMath::identity());
                        }
                    }
                }

                ColorRGBA wireColor = ColorRGBA::white();
                if (node.hasProperty<WireframeProperty>()) {
                    wireColor = node.getProperty<WireframeProperty>().wireColor;
                }

                auto data = ShaderDrawDataWireframe();

                data.model = model;
                data.mvp = projection * view * model;
                data.objectID_boneOffset[0] = static_cast<int>(oi);
                data.objectID_boneOffset[1] = static_cast<int>(boneOffset);

                auto col = wireColor.divide().getMemory();
                data.wireColor[0] = col[0];
                data.wireColor[1] = col[1];
                data.wireColor[2] = col[2];
                data.wireColor[3] = col[3];

                shaderData.emplace_back(data);

                auto &draw = drawData.data.at(i);

                drawCalls.emplace_back(draw.drawCall);
                baseVertices.emplace_back(draw.baseVertex);
            }
        }

        if (!shaderData.empty()) {
            builder.upload(shaderBuffer,
                           [shaderData]() {
                               return FrameGraphUploadBuffer::createArray(shaderData);
                           });

            builder.upload(boneBuffer,
                           [boneMatrices]() {
                               return FrameGraphUploadBuffer::createArray(boneMatrices);
                           });

            builder.beginPass({
                                      FrameGraphAttachment::texture(screenColor)
                              },
                              FrameGraphAttachment::texture(screenDepth));

            builder.setViewport({}, resolution);

            builder.bindPipeline(renderPipeline);
            builder.bindVertexBuffers(vertexBuffer, indexBuffer, {}, SkinnedMesh::getDefaultVertexLayout(), {});
            builder.bindShaderResources(std::vector<FrameGraphCommand::ShaderData>{
                    {shaderBuffer, {{VERTEX, ShaderResource::READ}, {FRAGMENT, ShaderResource::READ}}},
                    {boneBuffer,   {{VERTEX, ShaderResource::READ}}},
            });

            builder.multiDrawIndexed(drawCalls, baseVertices);

            builder.finishPass();
        }
    }

    std::type_index WireframePass::getTypeIndex() const {
        return typeid(WireframePass);
    }
}
