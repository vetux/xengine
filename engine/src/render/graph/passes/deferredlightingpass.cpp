/**
 *  This file is part of xEngine, a C++ game engine library.
 *  Copyright (C) 2023  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "xng/render/graph/passes/deferredlightingpass.hpp"

#include "xng/render/graph/framegraphbuilder.hpp"

#include "xng/render/graph/passes/constructionpass.hpp"
#include "xng/render/graph/framegraphproperties.hpp"

#include "xng/geometry/vertexstream.hpp"

#include "graph/phongdeferredpass_vs.hpp" // Generated by cmake
#include "graph/phongdeferredpass_fs.hpp" // Generated by cmake

namespace xng {
#pragma pack(push, 1)
    struct DirectionalLightData {
        std::array<float, 4> ambient;
        std::array<float, 4> diffuse;
        std::array<float, 4> specular;
        std::array<float, 4> direction;
    };

    struct PointLightData {
        std::array<float, 4> ambient;
        std::array<float, 4> diffuse;
        std::array<float, 4> specular;
        std::array<float, 4> position;
        std::array<float, 4> constant_linear_quadratic;
    };

    struct SpotLightData {
        std::array<float, 4> ambient;
        std::array<float, 4> diffuse;
        std::array<float, 4> specular;
        std::array<float, 4> position;
        std::array<float, 4> direction_quadratic;
        std::array<float, 4> cutOff_outerCutOff_constant_linear;
    };

    struct UniformBuffer {
        std::array<float, 4> viewPosition{};
    };
#pragma pack(pop)

    std::vector<DirectionalLightData> getDirLights(const std::vector<DirectionalLight> &lights) {
        std::vector<DirectionalLightData> ret;
        for (auto &l: lights) {
            auto tmp = DirectionalLightData{
                    .ambient = Vec4f(l.ambient.x, l.ambient.y, l.ambient.z, 1).getMemory(),
                    .diffuse = Vec4f(l.diffuse.x, l.diffuse.y, l.diffuse.z, 1).getMemory(),
                    .specular = Vec4f(l.specular.x, l.specular.y, l.specular.z, 1).getMemory(),
            };
            auto euler = (Quaternion(l.direction) * l.transform.getRotation()).getEulerAngles();
            tmp.direction = Vec4f(euler.x, euler.y, euler.z, 0).getMemory();
            ret.emplace_back();
        }
        return ret;
    }

    std::vector<PointLightData> getPointLights(const std::vector<PointLight> &lights) {
        std::vector<PointLightData> ret;
        for (auto &l: lights) {
            auto tmp = PointLightData{
                    .ambient = Vec4f(l.ambient.x, l.ambient.y, l.ambient.z, 1).getMemory(),
                    .diffuse = Vec4f(l.diffuse.x, l.diffuse.y, l.diffuse.z, 1).getMemory(),
                    .specular = Vec4f(l.specular.x, l.specular.y, l.specular.z, 1).getMemory(),
            };
            tmp.position = Vec4f(l.transform.getPosition().x,
                                 l.transform.getPosition().y,
                                 l.transform.getPosition().z,
                                 0).getMemory();
            tmp.constant_linear_quadratic[0] = l.constant;
            tmp.constant_linear_quadratic[1] = l.linear;
            tmp.constant_linear_quadratic[2] = l.quadratic;
            ret.emplace_back(tmp);
        }
        return ret;
    }

    std::vector<SpotLightData> getSpotLights(const std::vector<SpotLight> &lights) {
        std::vector<SpotLightData> ret;
        for (auto &l: lights) {
            auto tmp = SpotLightData{
                    .ambient = Vec4f(l.ambient.x, l.ambient.y, l.ambient.z, 1).getMemory(),
                    .diffuse = Vec4f(l.diffuse.x, l.diffuse.y, l.diffuse.z, 1).getMemory(),
                    .specular = Vec4f(l.specular.x, l.specular.y, l.specular.z, 1).getMemory(),
            };
            tmp.position = Vec4f(l.transform.getPosition().x,
                                 l.transform.getPosition().y,
                                 l.transform.getPosition().z,
                                 0).getMemory();

            auto euler = (Quaternion(l.direction) * l.transform.getRotation()).getEulerAngles();

            tmp.direction_quadratic[0] = euler.x;
            tmp.direction_quadratic[1] = euler.y;
            tmp.direction_quadratic[2] = euler.z;
            tmp.direction_quadratic[3] = l.quadratic;

            tmp.cutOff_outerCutOff_constant_linear[0] = l.cutOff;
            tmp.cutOff_outerCutOff_constant_linear[1] = l.outerCutOff;
            tmp.cutOff_outerCutOff_constant_linear[2] = l.constant;
            tmp.cutOff_outerCutOff_constant_linear[3] = l.linear;

            ret.emplace_back(tmp);
        }
        return ret;
    }

    DeferredLightingPass::DeferredLightingPass() = default;

    void DeferredLightingPass::setup(FrameGraphBuilder &builder) {
        if (!vertexBufferRes.assigned) {
            VertexBufferDesc desc;
            desc.size = mesh.vertices.size() * mesh.vertexLayout.getSize();
            vertexBufferRes = builder.createVertexBuffer(desc);

            VertexArrayObjectDesc oDesc;
            oDesc.vertexLayout = mesh.vertexLayout;
            vertexArrayObjectRes = builder.createVertexArrayObject(oDesc);

            builder.write(vertexBufferRes);
        }

        builder.persist(vertexBufferRes);
        builder.persist(vertexArrayObjectRes);
        builder.read(vertexBufferRes);
        builder.read(vertexArrayObjectRes);

        if (!pipelineRes.assigned) {
            pipelineRes = builder.createPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   phongdeferredpass_vs.getShader()},
                            {FRAGMENT, phongdeferredpass_fs.getShader()}
                    },
                    .bindings = {BIND_SHADER_UNIFORM_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER},
                    .primitive = TRIANGLES,
                    .vertexLayout = mesh.vertexLayout,
                    .enableDepthTest = true,
                    .depthTestWrite = true,
            });
        }

        builder.persist(pipelineRes);
        builder.read(pipelineRes);

        renderSize = builder.getBackBufferDescription().size
                     * builder.getProperties().get<float>(FrameGraphProperties::RENDER_SCALE, 1);

        targetRes = builder.createRenderTarget(RenderTargetDesc{
                .size = renderSize,
                .numberOfColorAttachments = 1,
                .hasDepthStencilAttachment = true
        });
        builder.read(targetRes);

        colorTextureRes = builder.getSlot(SLOT_DEFERRED_COLOR);
        builder.write(colorTextureRes);

        depthTextureRes = builder.getSlot(SLOT_DEFERRED_DEPTH);
        builder.write(depthTextureRes);

        passRes = builder.createRenderPass(RenderPassDesc{
                .numberOfColorAttachments = 1,
                .hasDepthStencilAttachment = true});

        builder.read(passRes);

        uniformBufferRes = builder.createShaderUniformBuffer(ShaderUniformBufferDesc{.size =  sizeof(UniformBuffer)});
        builder.read(uniformBufferRes);
        builder.write(uniformBufferRes);

        pointLights = builder.getScene().pointLights;
        spotLights = builder.getScene().spotLights;
        directionalLights = builder.getScene().directionalLights;

        pointLightsBufferRes = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(PointLightData) * pointLights.size()
        });
        builder.read(pointLightsBufferRes);
        builder.write(pointLightsBufferRes);

        spotLightsBufferRes = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(SpotLightData) * spotLights.size()
        });
        builder.read(spotLightsBufferRes);
        builder.write(spotLightsBufferRes);

        directionalLightsBufferRes = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(DirectionalLightData) * directionalLights.size()
        });
        builder.read(directionalLightsBufferRes);
        builder.write(directionalLightsBufferRes);

        gBufferPosition = builder.getSlot(SLOT_GBUFFER_POSITION);
        builder.read(gBufferPosition);

        gBufferNormal = builder.getSlot(SLOT_GBUFFER_NORMAL);
        builder.read(gBufferNormal);

        gBufferTangent = builder.getSlot(SLOT_GBUFFER_TANGENT);
        builder.read(gBufferTangent);

        gBufferRoughnessMetallicAO = builder.getSlot(SLOT_GBUFFER_ROUGHNESS_METALLIC_AO);
        builder.read(gBufferRoughnessMetallicAO);

        gBufferAlbedo = builder.getSlot(SLOT_GBUFFER_ALBEDO);
        builder.read(gBufferAlbedo);

        gBufferAmbient = builder.getSlot(SLOT_GBUFFER_AMBIENT);
        builder.read(gBufferAmbient);

        gBufferSpecular = builder.getSlot(SLOT_GBUFFER_SPECULAR);
        builder.read(gBufferSpecular);

        gBufferModelObject = builder.getSlot(SLOT_GBUFFER_MODEL_OBJECT);
        builder.read(gBufferModelObject);

        gBufferDepth = builder.getSlot(SLOT_GBUFFER_DEPTH);
        builder.read(gBufferDepth);

        cameraTransform = builder.getScene().cameraTransform;
    }

    void DeferredLightingPass::execute(FrameGraphPassResources &resources) {
        auto &target = resources.get<RenderTarget>(targetRes);

        auto &pipeline = resources.get<RenderPipeline>(pipelineRes);
        auto &pass = resources.get<RenderPass>(passRes);

        auto &vertexBuffer = resources.get<VertexBuffer>(vertexBufferRes);
        auto &vertexArrayObject = resources.get<VertexArrayObject>(vertexArrayObjectRes);

        auto &uniformBuffer = resources.get<ShaderUniformBuffer>(uniformBufferRes);

        auto &pointLightBuffer = resources.get<ShaderStorageBuffer>(pointLightsBufferRes);
        auto &spotLightBuffer = resources.get<ShaderStorageBuffer>(spotLightsBufferRes);
        auto &dirLightBuffer = resources.get<ShaderStorageBuffer>(directionalLightsBufferRes);

        auto &colorTex = resources.get<TextureBuffer>(colorTextureRes);
        auto &depthTex = resources.get<TextureBuffer>(depthTextureRes);

        auto plights = getPointLights(pointLights);
        auto slights = getSpotLights(spotLights);
        auto dlights = getDirLights(directionalLights);

        pointLightBuffer.upload(reinterpret_cast<const uint8_t *>(plights.data()),
                                plights.size() * sizeof(PointLightData));
        spotLightBuffer.upload(reinterpret_cast<const uint8_t *>(slights.data()),
                               slights.size() * sizeof(SpotLightData));
        dirLightBuffer.upload(reinterpret_cast<const uint8_t *>(dlights.data()),
                              dlights.size() * sizeof(DirectionalLightData));

        if (!quadAllocated) {
            quadAllocated = true;
            auto verts = VertexStream().addVertices(mesh.vertices).getVertexBuffer();
            vertexBuffer.upload(0,
                                verts.data(),
                                verts.size());
            vertexArrayObject.bindBuffers(vertexBuffer);
        }

        UniformBuffer buf;
        buf.viewPosition = Vec4f(cameraTransform.getPosition().x,
                                 cameraTransform.getPosition().y,
                                 cameraTransform.getPosition().z,
                                 0).getMemory();
        uniformBuffer.upload(buf);

        auto &gBufPos = resources.get<TextureBuffer>(gBufferPosition);
        auto &gBufNorm = resources.get<TextureBuffer>(gBufferNormal);
        auto &gBufTan = resources.get<TextureBuffer>(gBufferTangent);
        auto &gBufRoughnessMetallicAO = resources.get<TextureBuffer>(gBufferRoughnessMetallicAO);
        auto &gBufAlbedo = resources.get<TextureBuffer>(gBufferAlbedo);
        auto &gBufAmbient = resources.get<TextureBuffer>(gBufferAmbient);
        auto &gBufSpecular = resources.get<TextureBuffer>(gBufferSpecular);
        auto &gBufModelObject = resources.get<TextureBuffer>(gBufferModelObject);
        auto &gBufDepth = resources.get<TextureBuffer>(gBufferDepth);

        target.setColorAttachments({colorTex});
        target.setDepthStencilAttachment(depthTex);

        pass.beginRenderPass(target, {}, target.getDescription().size);

        pass.bindPipeline(pipeline);
        pass.bindVertexArrayObject(vertexArrayObject);
        pass.bindShaderData({
                                    uniformBuffer,
                                    pointLightBuffer,
                                    spotLightBuffer,
                                    dirLightBuffer,
                                    gBufPos,
                                    gBufNorm,
                                    gBufRoughnessMetallicAO,
                                    gBufAlbedo,
                                    gBufAmbient,
                                    gBufSpecular,
                                    gBufModelObject,
                                    gBufDepth
                            });
        pass.drawArray(RenderPass::DrawCall(0, mesh.vertices.size()));
        pass.endRenderPass();

        target.setColorAttachments({});
        target.clearDepthStencilAttachment();
    }

    std::type_index DeferredLightingPass::getTypeIndex() const {
        return typeid(DeferredLightingPass);
    }
}