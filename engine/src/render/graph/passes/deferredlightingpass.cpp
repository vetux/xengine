/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2024  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "xng/render/graph/passes/deferredlightingpass.hpp"

#include "xng/render/graph/framegraphbuilder.hpp"
#include "xng/render/graph/framegraphsettings.hpp"

#include "xng/render/geometry/vertexstream.hpp"

#include "graph/deferredlightingpass_vs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_fs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_cubemap_vs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_convertmap_fs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_prefilter_fs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_irradiance_fs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_brdf_vs.hpp" // Generated by cmake
#include "graph/deferredlightingpass_brdf_fs.hpp" // Generated by cmake

//TODO: Fix IBL Render not outputting reflections and outputting black object outlines

namespace xng {
#pragma pack(push, 1)
    struct PointLightData {
        std::array<float, 4> position;
        std::array<float, 4> color;
        std::array<float, 4> farPlane;
    };

    struct DirectionalLightData {
        std::array<float, 4> direction;
        std::array<float, 4> color;
        std::array<float, 4> farPlane;
    };

    struct SpotLightData {
        std::array<float, 4> position;
        std::array<float, 4> direction_quadratic;
        std::array<float, 4> color;
        std::array<float, 4> farPlane;
        std::array<float, 4> cutOff_outerCutOff_constant_linear;
    };

    struct ShaderStorageData {
        std::array<float, 4> viewPosition{};
        std::array<int, 4> enableShadows{};
    };
#pragma pack(pop)

    static std::pair<std::vector<PointLightData>, std::vector<PointLightData>> getPointLights(const Scene &scene) {
        std::vector<PointLightData> lights;
        std::vector<PointLightData> shadowLights;
        for (auto &node: scene.rootNode.findAll({typeid(PointLightProperty)})) {
            auto l = node.getProperty<PointLightProperty>().light;
            auto t = node.getProperty<TransformProperty>().transform;
            auto v = l.color.divide();
            auto tmp = PointLightData{
                    .position =  Vec4f(t.getPosition().x,
                                       t.getPosition().y,
                                       t.getPosition().z,
                                       0).getMemory(),
                    .color = Vec4f(v.x * l.power, v.y * l.power, v.z * l.power, 1).getMemory(),
                    .farPlane = Vec4f(l.shadowFarPlane, 0, 0, 0).getMemory()
            };
            if (l.castShadows)
                shadowLights.emplace_back(tmp);
            else
                lights.emplace_back(tmp);
        }
        return {lights, shadowLights};
    }

    static std::pair<std::vector<DirectionalLightData>, std::vector<DirectionalLightData>>
    getDirLights(const Scene &scene) {
        std::vector<DirectionalLightData> lights;
        std::vector<DirectionalLightData> shadowLights;
        for (auto &node: scene.rootNode.findAll({typeid(DirectionalLightProperty)})) {
            auto l = node.getProperty<DirectionalLightProperty>().light;
            auto v = l.color.divide();
            auto tmp = DirectionalLightData{
                    .direction =  Vec4f(l.direction.x,
                                        l.direction.y,
                                        l.direction.z,
                                        0).getMemory(),
                    .color = Vec4f(v.x * l.power, v.y * l.power, v.z * l.power, 1).getMemory(),
                    .farPlane = Vec4f(l.shadowFarPlane, 0, 0, 0).getMemory()
            };
            if (l.castShadows)
                shadowLights.emplace_back(tmp);
            else
                lights.emplace_back(tmp);
        }
        return {lights, shadowLights};
    }

    static float getCutOff(float angleDegrees) {
        return std::cos(degreesToRadians(angleDegrees));
    }

    static std::pair<std::vector<SpotLightData>, std::vector<SpotLightData>> getSpotLights(const Scene &scene) {
        std::vector<SpotLightData> lights;
        std::vector<SpotLightData> shadowLights;
        for (auto &node: scene.rootNode.findAll({typeid(SpotLightProperty)})) {
            auto l = node.getProperty<SpotLightProperty>().light;
            auto t = node.getProperty<TransformProperty>().transform;
            auto v = l.color.divide();
            auto tmp = SpotLightData{
                    .position =  Vec4f(t.getPosition().x,
                                       t.getPosition().y,
                                       t.getPosition().z,
                                       0).getMemory(),
                    .direction_quadratic =  Vec4f(l.direction.x,
                                                  l.direction.y,
                                                  l.direction.z,
                                                  l.quadratic).getMemory(),
                    .color = Vec4f(v.x * l.power, v.y * l.power, v.z * l.power, 1).getMemory(),
                    .farPlane = Vec4f(l.shadowFarPlane, 0, 0, 0).getMemory(),
                    .cutOff_outerCutOff_constant_linear = Vec4f(getCutOff(l.cutOff),
                                                                getCutOff(l.outerCutOff),
                                                                l.constant,
                                                                l.linear).getMemory()
            };
            if (l.castShadows)
                shadowLights.emplace_back(tmp);
            else
                lights.emplace_back(tmp);
        }
        return {lights, shadowLights};
    }

    /**
     * Magic cube from the tutorial at:
     * https://github.com/JoeyDeVries/LearnOpenGL/blob/3e94252892660902bef62068c35253cbe3464c9b/src/6.pbr/2.2.2.ibl_specular_textured/ibl_specular_textured.cpp#L710
     * @return
     */
    Mesh getMagicCube() {
        std::vector<float> vertices = {
                // back face
                -1.0f, -1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 0.0f, 0.0f, // bottom-left
                1.0f,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 1.0f, 1.0f, // top-right
                1.0f, -1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 1.0f, 0.0f, // bottom-right
                1.0f,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 1.0f, 1.0f, // top-right
                -1.0f, -1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 0.0f, 0.0f, // bottom-left
                -1.0f,  1.0f, -1.0f,  0.0f,  0.0f, -1.0f, 0.0f, 1.0f, // top-left
                // front face
                -1.0f, -1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f, 0.0f, // bottom-left
                1.0f, -1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f, 0.0f, // bottom-right
                1.0f,  1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f, 1.0f, // top-right
                1.0f,  1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 1.0f, 1.0f, // top-right
                -1.0f,  1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f, 1.0f, // top-left
                -1.0f, -1.0f,  1.0f,  0.0f,  0.0f,  1.0f, 0.0f, 0.0f, // bottom-left
                // left face
                -1.0f,  1.0f,  1.0f, -1.0f,  0.0f,  0.0f, 1.0f, 0.0f, // top-right
                -1.0f,  1.0f, -1.0f, -1.0f,  0.0f,  0.0f, 1.0f, 1.0f, // top-left
                -1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  0.0f, 0.0f, 1.0f, // bottom-left
                -1.0f, -1.0f, -1.0f, -1.0f,  0.0f,  0.0f, 0.0f, 1.0f, // bottom-left
                -1.0f, -1.0f,  1.0f, -1.0f,  0.0f,  0.0f, 0.0f, 0.0f, // bottom-right
                -1.0f,  1.0f,  1.0f, -1.0f,  0.0f,  0.0f, 1.0f, 0.0f, // top-right
                // right face
                1.0f,  1.0f,  1.0f,  1.0f,  0.0f,  0.0f, 1.0f, 0.0f, // top-left
                1.0f, -1.0f, -1.0f,  1.0f,  0.0f,  0.0f, 0.0f, 1.0f, // bottom-right
                1.0f,  1.0f, -1.0f,  1.0f,  0.0f,  0.0f, 1.0f, 1.0f, // top-right
                1.0f, -1.0f, -1.0f,  1.0f,  0.0f,  0.0f, 0.0f, 1.0f, // bottom-right
                1.0f,  1.0f,  1.0f,  1.0f,  0.0f,  0.0f, 1.0f, 0.0f, // top-left
                1.0f, -1.0f,  1.0f,  1.0f,  0.0f,  0.0f, 0.0f, 0.0f, // bottom-left
                // bottom face
                -1.0f, -1.0f, -1.0f,  0.0f, -1.0f,  0.0f, 0.0f, 1.0f, // top-right
                1.0f, -1.0f, -1.0f,  0.0f, -1.0f,  0.0f, 1.0f, 1.0f, // top-left
                1.0f, -1.0f,  1.0f,  0.0f, -1.0f,  0.0f, 1.0f, 0.0f, // bottom-left
                1.0f, -1.0f,  1.0f,  0.0f, -1.0f,  0.0f, 1.0f, 0.0f, // bottom-left
                -1.0f, -1.0f,  1.0f,  0.0f, -1.0f,  0.0f, 0.0f, 0.0f, // bottom-right
                -1.0f, -1.0f, -1.0f,  0.0f, -1.0f,  0.0f, 0.0f, 1.0f, // top-right
                // top face
                -1.0f,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f, 0.0f, 1.0f, // top-left
                1.0f,  1.0f , 1.0f,  0.0f,  1.0f,  0.0f, 1.0f, 0.0f, // bottom-right
                1.0f,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f, 1.0f, 1.0f, // top-right
                1.0f,  1.0f,  1.0f,  0.0f,  1.0f,  0.0f, 1.0f, 0.0f, // bottom-right
                -1.0f,  1.0f, -1.0f,  0.0f,  1.0f,  0.0f, 0.0f, 1.0f, // top-left
                -1.0f,  1.0f,  1.0f,  0.0f,  1.0f,  0.0f, 0.0f, 0.0f  // bottom-left
        };

        std::vector<Vertex> verts;

        for (auto i = 0; i < vertices.size(); i += 8) {
            verts.emplace_back(VertexBuilder()
                                       .addVec3(Vec3f{vertices.at(i), vertices.at(i + 1), vertices.at(i + 2)})
                                       .addVec3(Vec3f{vertices.at(i + 3), vertices.at(i + 4), vertices.at(i + 5)})
                                       .addVec2(Vec2f{vertices.at(i + 6), vertices.at(i + 7)})
                                       .build());
        }

        VertexLayout layout;
        layout.attributes.emplace_back(VertexAttribute::Type::VECTOR3, VertexAttribute::Component::FLOAT, 0);
        layout.attributes.emplace_back(VertexAttribute::Type::VECTOR3, VertexAttribute::Component::FLOAT, 0);
        layout.attributes.emplace_back(VertexAttribute::Type::VECTOR2, VertexAttribute::Component::FLOAT, 0);

        Mesh ret;
        ret.vertexLayout = layout;
        ret.vertices = verts;

        return ret;
    }

    void DeferredLightingPass::setup(FrameGraphBuilder &builder) {
        auto scene = builder.getScene();

        if (!quadVertexBuffer.assigned) {
            VertexBufferDesc desc;
            desc.size = quadMesh.vertices.size() * quadMesh.vertexLayout.getSize();
            quadVertexBuffer = builder.createVertexBuffer(desc);
            builder.upload(quadVertexBuffer, [this]() {
                return FrameGraphUploadBuffer::createArray(
                        VertexStream().addVertices(quadMesh.vertices).getVertexBuffer());
            });

            desc = {};
            desc.size = cubeMesh.vertices.size() * cubeMesh.vertexLayout.getSize();
            cubeVertexBuffer = builder.createVertexBuffer(desc);
            builder.upload(cubeVertexBuffer, [this]() {
                return FrameGraphUploadBuffer::createArray(
                        VertexStream().addVertices(cubeMesh.vertices).getVertexBuffer());
            });

            magicCubeMesh = getMagicCube();
            desc = {};
            desc.size = magicCubeMesh.vertices.size() * magicCubeMesh.vertexLayout.getSize();
            magicCubeVertexBuffer = builder.createVertexBuffer(desc);
            builder.upload(magicCubeVertexBuffer,
                           [this]() {
                               return FrameGraphUploadBuffer::createArray(
                                       VertexStream().addVertices(magicCubeMesh.vertices).getVertexBuffer());
                           });
        }

        builder.persist(quadVertexBuffer);
        builder.persist(cubeVertexBuffer);
        builder.persist(magicCubeVertexBuffer);

        if (!pipeline.assigned) {
            pipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   deferredlightingpass_vs},
                            {FRAGMENT, deferredlightingpass_fs}
                    },
                    .bindings = {BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_ARRAY_BUFFER,
                                 BIND_TEXTURE_ARRAY_BUFFER,
                                 BIND_TEXTURE_ARRAY_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                    },
                    .primitive = TRIANGLES,
                    .vertexLayout = quadMesh.vertexLayout,
                    .enableDepthTest = true,
                    .depthTestWrite = true,
            });

            convertMapPipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   deferredlightingpass_cubemap_vs},
                            {FRAGMENT, deferredlightingpass_convertmap_fs}
                    },
                    .bindings = {BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                    },
                    .primitive = TRIANGLES,
                    .vertexLayout = cubeMesh.vertexLayout,
                    .enableDepthTest = false,
                    .depthTestWrite = false,
            });
            prefilterPipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   deferredlightingpass_cubemap_vs},
                            {FRAGMENT, deferredlightingpass_prefilter_fs}
                    },
                    .bindings = {BIND_SHADER_STORAGE_BUFFER,
                                 BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                    },
                    .primitive = TRIANGLES,
                    .vertexLayout = cubeMesh.vertexLayout,
                    .enableDepthTest = false,
                    .depthTestWrite = false,
            });
            irradiancePipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   deferredlightingpass_cubemap_vs},
                            {FRAGMENT, deferredlightingpass_irradiance_fs}
                    },
                    .bindings = {BIND_SHADER_STORAGE_BUFFER,
                                 BIND_TEXTURE_BUFFER,
                    },
                    .primitive = TRIANGLES,
                    .vertexLayout = cubeMesh.vertexLayout,
                    .enableDepthTest = false,
                    .depthTestWrite = false,
            });
            brdfPipeline = builder.createRenderPipeline(RenderPipelineDesc{
                    .shaders = {
                            {VERTEX,   deferredlightingpass_brdf_vs},
                            {FRAGMENT, deferredlightingpass_brdf_fs}
                    },
                    .bindings = {},
                    .primitive = TRIANGLES,
                    .vertexLayout = quadMesh.vertexLayout,
                    .enableDepthTest = false,
                    .depthTestWrite = false,
            });
        }

        builder.persist(pipeline);
        builder.persist(convertMapPipeline);
        builder.persist(prefilterPipeline);
        builder.persist(irradiancePipeline);
        builder.persist(brdfPipeline);

        auto envProps = scene.rootNode.findAll({typeid(IBLLightingProperty)});
        if (envProps.empty()) {
            if (!currentEnvironmentTexture.empty() || !environmentMap.assigned) {
                generateEnvironmentMaps(builder, {});
                currentEnvironmentTexture = {};
            }
        } else {
            auto &prop = envProps.at(0);
            if (currentEnvironmentTexture != prop.getProperty<IBLLightingProperty>().hdrImage.getUri()) {
                generateEnvironmentMaps(builder, prop.getProperty<IBLLightingProperty>().hdrImage);
                currentEnvironmentTexture = prop.getProperty<IBLLightingProperty>().hdrImage.getUri();
            }
        }

        builder.persist(environmentMap);
        builder.persist(prefilterMap);
        builder.persist(irradianceMap);
        builder.persist(brdfMap);

        auto resolution = builder.getRenderResolution();

        auto deferredColor = builder.getSlot(SLOT_DEFERRED_COLOR);
        auto deferredDepth = builder.getSlot(SLOT_DEFERRED_DEPTH);

        auto pointLightNodes = scene.rootNode.findAll({typeid(PointLightProperty)});

        size_t pointLightCount = 0;
        size_t shadowPointLightCount = 0;

        for (auto l: pointLightNodes) {
            if (l.getProperty<PointLightProperty>().light.castShadows)
                shadowPointLightCount++;
            else
                pointLightCount++;
        }

        auto dirLightNodes = scene.rootNode.findAll({typeid(DirectionalLightProperty)});

        size_t dirLightCount = 0;
        size_t shadowDirLightCount = 0;

        std::vector<Mat4f> dirShadowMatrices;
        std::vector<Mat4f> spotShadowMatrices;

        for (auto l: dirLightNodes) {
            if (l.getProperty<DirectionalLightProperty>().light.castShadows) {
                auto &light = l.getProperty<DirectionalLightProperty>().light;
                dirShadowMatrices.emplace_back(MatrixMath::ortho(-light.shadowProjectionExtent,
                                                                 light.shadowProjectionExtent,
                                                                 -light.shadowProjectionExtent,
                                                                 light.shadowProjectionExtent,
                                                                 light.shadowNearPlane,
                                                                 light.shadowFarPlane)
                                               * MatrixMath::lookAt(
                        Vec3f(light.shadowPosition.x, 0, light.shadowPosition.y),
                        Vec3f(light.shadowPosition.x, 0, light.shadowPosition.y) + light.direction,
                        Vec3f(0, 1, 0)));
                shadowDirLightCount++;
            } else
                dirLightCount++;
        }

        auto spotLightNodes = scene.rootNode.findAll({typeid(SpotLightProperty)});

        size_t spotLightCount = 0;
        size_t shadowSpotLightCount = 0;

        auto spotShadowResolution = builder.getSettings().get<Vec2i>(
                FrameGraphSettings::SETTING_SHADOW_MAPPING_SPOT_RESOLUTION);

        for (auto l: spotLightNodes) {
            if (l.getProperty<SpotLightProperty>().light.castShadows) {
                auto &transform = l.getProperty<TransformProperty>().transform;
                auto &light = l.getProperty<SpotLightProperty>().light;
                float aspect = (float) spotShadowResolution.x / (float) spotShadowResolution.y;
                spotShadowMatrices.emplace_back(MatrixMath::perspective(45,
                                                                        aspect,
                                                                        light.shadowNearPlane,
                                                                        light.shadowFarPlane)
                                                * MatrixMath::lookAt(transform.getPosition(),
                                                                     transform.getPosition() + light.direction,
                                                                     Vec3f(0, 1, 0)));
                shadowSpotLightCount++;
            } else
                spotLightCount++;
        }

        auto shaderDataBuffer = builder.createShaderStorageBuffer(
                ShaderStorageBufferDesc{.size =  sizeof(ShaderStorageData)});

        auto pointLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(PointLightData) * pointLightCount
        });

        auto shadowPointLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(PointLightData) * shadowPointLightCount
        });

        auto dirLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(DirectionalLightData) * dirLightCount
        });

        auto shadowDirLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(DirectionalLightData) * shadowDirLightCount
        });

        auto spotLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(SpotLightData) * spotLightCount
        });

        auto shadowSpotLightBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(SpotLightData) * shadowSpotLightCount
        });

        auto dirShadowTransformBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(Mat4f) * dirShadowMatrices.size()
        });

        auto spotShadowTransformBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(Mat4f) * spotShadowMatrices.size()
        });

        auto pointLights = getPointLights(scene);
        auto dirLights = getDirLights(scene);
        auto spotLights = getSpotLights(scene);

        builder.upload(pointLightBuffer,
                       [pointLights]() {
                           return FrameGraphUploadBuffer::createArray(pointLights.first);
                       });
        builder.upload(shadowPointLightBuffer,
                       [pointLights]() {
                           return FrameGraphUploadBuffer::createArray(pointLights.second);
                       });

        builder.upload(dirLightBuffer,
                       [dirLights]() {
                           return FrameGraphUploadBuffer::createArray(dirLights.first);
                       });
        builder.upload(shadowDirLightBuffer,
                       [dirLights]() {
                           return FrameGraphUploadBuffer::createArray(dirLights.second);
                       });

        builder.upload(spotLightBuffer,
                       [spotLights]() {
                           return FrameGraphUploadBuffer::createArray(spotLights.first);
                       });
        builder.upload(shadowSpotLightBuffer,
                       [spotLights]() {
                           return FrameGraphUploadBuffer::createArray(spotLights.second);
                       });

        builder.upload(dirShadowTransformBuffer,
                       [dirShadowMatrices]() {
                           return FrameGraphUploadBuffer::createArray(dirShadowMatrices);
                       });
        builder.upload(spotShadowTransformBuffer,
                       [spotShadowMatrices]() {
                           return FrameGraphUploadBuffer::createArray(spotShadowMatrices);
                       });

        auto gBufferPosition = builder.getSlot(SLOT_GBUFFER_POSITION);
        auto gBufferNormal = builder.getSlot(SLOT_GBUFFER_NORMAL);
        auto gBufferRoughnessMetallicAO = builder.getSlot(SLOT_GBUFFER_ROUGHNESS_METALLIC_AO);
        auto gBufferAlbedo = builder.getSlot(SLOT_GBUFFER_ALBEDO);
        auto gBufferModelObject = builder.getSlot(SLOT_GBUFFER_OBJECT_SHADOWS);
        auto gBufferDepth = builder.getSlot(SLOT_GBUFFER_DEPTH);

        auto cameraTransform = builder.getScene().rootNode.find<CameraProperty>()
                .getProperty<TransformProperty>().transform;

        FrameGraphResource pointLightShadowMap{};
        if (builder.checkSlot(SLOT_SHADOW_MAP_POINT)) {
            pointLightShadowMap = builder.getSlot(FrameGraphSlot::SLOT_SHADOW_MAP_POINT);
        }

        FrameGraphResource dirLightShadowMap{};
        if (builder.checkSlot(SLOT_SHADOW_MAP_DIRECTIONAL)) {
            dirLightShadowMap = builder.getSlot(FrameGraphSlot::SLOT_SHADOW_MAP_DIRECTIONAL);
        }

        FrameGraphResource spotLightShadowMap{};
        if (builder.checkSlot(SLOT_SHADOW_MAP_SPOT)) {
            spotLightShadowMap = builder.getSlot(FrameGraphSlot::SLOT_SHADOW_MAP_SPOT);
        }

        auto defaultShadowMap = builder.createTextureArrayBuffer({});

        builder.upload(shaderDataBuffer,
                       [cameraTransform, pointLightShadowMap]() {
                           ShaderStorageData buf;
                           buf.viewPosition = Vec4f(cameraTransform.getPosition().x,
                                                    cameraTransform.getPosition().y,
                                                    cameraTransform.getPosition().z,
                                                    0).getMemory();
                           buf.enableShadows.at(0) = pointLightShadowMap.assigned;
                           return FrameGraphUploadBuffer::createValue(buf);
                       });

        auto pointMap = pointLightShadowMap.assigned ? pointLightShadowMap : defaultShadowMap;
        auto dirMap = dirLightShadowMap.assigned ? dirLightShadowMap : defaultShadowMap;
        auto spotMap = spotLightShadowMap.assigned ? spotLightShadowMap : defaultShadowMap;

        builder.beginPass({FrameGraphAttachment::texture(deferredColor)}, FrameGraphAttachment::texture(deferredDepth));
        builder.setViewport({}, resolution);
        builder.bindPipeline(pipeline);
        builder.bindVertexBuffers(quadVertexBuffer, {}, {}, quadMesh.vertexLayout, {});
        builder.bindShaderResources({
                                            {shaderDataBuffer,           {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferPosition,            {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferNormal,              {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferRoughnessMetallicAO, {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferAlbedo,              {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferModelObject,         {{FRAGMENT, ShaderResource::READ}}},
                                            {gBufferDepth,               {{FRAGMENT, ShaderResource::READ}}},
                                            {pointMap,                   {{FRAGMENT, ShaderResource::READ}}},
                                            {dirMap,                     {{FRAGMENT, ShaderResource::READ}}},
                                            {spotMap,                    {{FRAGMENT, ShaderResource::READ}}},
                                            {pointLightBuffer,           {{FRAGMENT, ShaderResource::READ}}},
                                            {shadowPointLightBuffer,     {{FRAGMENT, ShaderResource::READ}}},
                                            {dirLightBuffer,             {{FRAGMENT, ShaderResource::READ}}},
                                            {shadowDirLightBuffer,       {{FRAGMENT, ShaderResource::READ}}},
                                            {spotLightBuffer,            {{FRAGMENT, ShaderResource::READ}}},
                                            {shadowSpotLightBuffer,      {{FRAGMENT, ShaderResource::READ}}},
                                            {dirShadowTransformBuffer,   {{FRAGMENT, ShaderResource::READ}}},
                                            {spotShadowTransformBuffer,  {{FRAGMENT, ShaderResource::READ}}},
                                            {irradianceMap,              {{FRAGMENT, ShaderResource::READ}}},
                                            {prefilterMap,               {{FRAGMENT, ShaderResource::READ}}},
                                            {brdfMap,                    {{FRAGMENT, ShaderResource::READ}}},
                                    });
        builder.drawArray(DrawCall(0, quadMesh.vertices.size()));
        builder.finishPass();
    }

    std::type_index DeferredLightingPass::getTypeIndex() const {
        return typeid(DeferredLightingPass);
    }

    void DeferredLightingPass::generateEnvironmentMaps(FrameGraphBuilder &builder,
                                                       const ResourceHandle<ImageRGBA> &hdrImage) {
        Mat4f captureProjection = MatrixMath::perspective(90.0f, 1.0f, 0.1f, 10.0f);
        Mat4f captureViews[] =
                {
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(1.0f, 0.0f, 0.0f), Vec3f(0.0f, -1.0f, 0.0f)),
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(-1.0f, 0.0f, 0.0f), Vec3f(0.0f, -1.0f, 0.0f)),
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(0.0f, 1.0f, 0.0f), Vec3f(0.0f, 0.0f, 1.0f)),
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(0.0f, -1.0f, 0.0f), Vec3f(0.0f, 0.0f, -1.0f)),
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(0.0f, 0.0f, 1.0f), Vec3f(0.0f, -1.0f, 0.0f)),
                        MatrixMath::lookAt(Vec3f(0.0f, 0.0f, 0.0f), Vec3f(0.0f, 0.0f, -1.0f), Vec3f(0.0f, -1.0f, 0.0f))
                };

        auto transformBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(Mat4f) * 2
        });

        builder.upload(transformBuffer, 0, [captureProjection]() {
            return FrameGraphUploadBuffer::createValue(captureProjection);
        });

        // Convert HDR equirectangular environment map to cubemap equivalent

        TextureBufferDesc desc{};

        FrameGraphResource hdrTexture;
        if (hdrImage.assigned()) {
            desc.textureType = TEXTURE_2D;
            desc.size = hdrImage.get().getResolution();
            desc.format = RGBA;

            hdrTexture = builder.createTextureBuffer(desc);

            builder.upload(hdrTexture,
                           0,
                           0,
                           RGBA,
                           {},
                           [hdrImage]() {
                               return FrameGraphUploadBuffer::createArray(hdrImage.get().getBuffer());
                           },
                           0);
        } else {
            desc.textureType = TEXTURE_2D;
            desc.size = {1, 1};
            desc.format = RGBA;

            hdrTexture = builder.createTextureBuffer(desc);

            builder.upload(hdrTexture,
                           0,
                           0,
                           RGBA,
                           {},
                           []() {
                               return FrameGraphUploadBuffer::createValue(ColorRGBA::black());
                           },
                           0);
        }

        desc = {};
        desc.textureType = TEXTURE_CUBE_MAP;
        desc.size = {512, 512};
        desc.format = RGB16F;
        desc.mipMapLevels = TextureBufferDesc::getMipMapLevelCount(desc.size);
        desc.wrapping = CLAMP_TO_EDGE;
        desc.mipMapFilter = LINEAR_MIPMAP_LINEAR;
        desc.filterMag = LINEAR;

        environmentMap = builder.createTextureBuffer(desc);

        for (auto face = POSITIVE_X; face <= NEGATIVE_Z; face = (CubeMapFace) ((int) face + 1)) {
            builder.upload(transformBuffer,
                           sizeof(Mat4f),
                           [captureViews, face]() {
                               return FrameGraphUploadBuffer::createValue(captureViews[(int) face]);
                           });

            builder.beginPass({FrameGraphAttachment::cubemap(environmentMap, face, 0)}, {});

            builder.setViewport({}, {512, 512});

            builder.clearColor(ColorRGBA(0));

            builder.bindPipeline(convertMapPipeline);
            builder.bindVertexBuffers(magicCubeVertexBuffer, {}, {}, magicCubeMesh.vertexLayout, {});
            builder.bindShaderResources({
                                                {transformBuffer, {{VERTEX,   ShaderResource::READ}}},
                                                {hdrTexture,      {{FRAGMENT, ShaderResource::READ}}},
                                        });

            builder.drawArray(DrawCall(0, magicCubeMesh.vertices.size()));

            builder.finishPass();
        }

        builder.generateMipMaps(environmentMap);

        // Create an irradiance cubemap, and re-scale capture FBO to irradiance scale

        desc.wrapping = CLAMP_TO_EDGE;
        desc.filterMin = LINEAR;
        desc.filterMag = LINEAR;
        desc.size = {32, 32};
        desc.mipMapLevels = 1;

        irradianceMap = builder.createTextureBuffer(desc);

        // Solve diffuse integral by convolution to create an irradiance (cube)map

        for (auto face = POSITIVE_X; face <= NEGATIVE_Z; face = (CubeMapFace) ((int) face + 1)) {
            builder.upload(transformBuffer,
                           sizeof(Mat4f),
                           [captureViews, face]() {
                               return FrameGraphUploadBuffer::createValue(captureViews[(int) face]);
                           });

            builder.beginPass({FrameGraphAttachment::cubemap(irradianceMap, face, 0)}, {});

            builder.setViewport({}, {32, 32});

            builder.clearColor(ColorRGBA(0));

            builder.bindPipeline(irradiancePipeline);
            builder.bindVertexBuffers(magicCubeVertexBuffer, {}, {}, magicCubeMesh.vertexLayout, {});
            builder.bindShaderResources({
                                                {transformBuffer, {{VERTEX,   ShaderResource::READ}}},
                                                {environmentMap,  {{FRAGMENT, ShaderResource::READ}}},
                                        });

            builder.drawArray(DrawCall(0, magicCubeMesh.vertices.size()));

            builder.finishPass();
        }

        // Create a pre-filter cubemap, and re-scale capture FBO to pre-filter scale

        desc.size = {128, 128};
        desc.mipMapLevels = 5;

        prefilterMap = builder.createTextureBuffer(desc);

        builder.generateMipMaps(prefilterMap);

        auto dataBuffer = builder.createShaderStorageBuffer(ShaderStorageBufferDesc{
                .size = sizeof(float) * 4
        });

        // Run a quasi monte-carlo simulation on the environment lighting to create a prefilter (cube)map

        for (unsigned int mip = 0; mip < 5; ++mip) {
            // reisze framebuffer according to mip-level size.
            unsigned int mipWidth = static_cast<unsigned int>(128 * std::pow(0.5, mip));
            unsigned int mipHeight = static_cast<unsigned int>(128 * std::pow(0.5, mip));

            float roughness = (float) mip / (float) (5 - 1);

            builder.upload(dataBuffer, [roughness]() {
                return FrameGraphUploadBuffer::createArray(std::vector<float>{roughness, 0, 0, 0});
            });

            for (auto face = POSITIVE_X; face <= NEGATIVE_Z; face = (CubeMapFace) ((int) face + 1)) {
                builder.upload(transformBuffer,
                               sizeof(Mat4f),
                               [captureViews, face]() {
                                   return FrameGraphUploadBuffer::createValue(captureViews[(int) face]);
                               });

                builder.beginPass({FrameGraphAttachment::cubemap(prefilterMap, face, mip)}, {});

                builder.setViewport({}, Vec2i{static_cast<int>(mipWidth), static_cast<int>(mipHeight)});

                builder.clearColor(ColorRGBA(0));

                builder.bindPipeline(prefilterPipeline);
                builder.bindVertexBuffers(magicCubeVertexBuffer, {}, {}, magicCubeMesh.vertexLayout, {});
                builder.bindShaderResources({
                                                    {transformBuffer, {{VERTEX,   ShaderResource::READ}}},
                                                    {dataBuffer,      {{FRAGMENT, ShaderResource::READ}}},
                                                    {environmentMap,  {{FRAGMENT, ShaderResource::READ}}},
                                            });

                builder.drawArray(DrawCall(0, magicCubeMesh.vertices.size()));

                builder.finishPass();
            }
        }

        // Generate a 2D LUT from the BRDF equations used
        if (!brdfMap.assigned) {
            desc = {};
            desc.textureType = TEXTURE_2D;
            desc.size = {512, 512};
            desc.format = RG16F;
            desc.wrapping = CLAMP_TO_EDGE;
            desc.filterMin = LINEAR;
            desc.filterMag = LINEAR;

            brdfMap = builder.createTextureBuffer(desc);

            builder.beginPass({FrameGraphAttachment::texture(brdfMap)}, {});

            builder.setViewport({}, {512, 512});

            builder.clearColor(ColorRGBA(0));

            builder.bindPipeline(brdfPipeline);
            builder.bindVertexBuffers(quadVertexBuffer, {}, {}, {}, {});

            builder.drawArray(DrawCall(0, quadMesh.vertices.size()));

            builder.finishPass();
        }
    }
}