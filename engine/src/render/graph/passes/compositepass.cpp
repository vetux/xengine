/**
 *  xEngine - C++ Game Engine Library
 *  Copyright (C) 2023  Julian Zampiccoli
 *
 *  This program is free software; you can redistribute it and/or modify
 *  it under the terms of the GNU Lesser General Public License as published by
 *  the Free Software Foundation; either version 2 of the License, or
 *  (at your option) any later version.
 *
 *  This program is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU Lesser General Public License for more details.
 *
 *  You should have received a copy of the GNU Lesser General Public License along
 *  with this program; if not, write to the Free Software Foundation, Inc.,
 *  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include "xng/render/graph/passes/compositepass.hpp"

#include "xng/render/graph/framegraphbuilder.hpp"
#include "xng/render/graph/framegraphproperties.hpp"

#include "xng/geometry/vertexstream.hpp"

#include "graph/compositepass_vs.hpp" // Generated by cmake
#include "graph/compositepass_fs.hpp" // Generated by cmake

namespace xng {
    CompositePass::CompositePass() = default;

    void CompositePass::setup(FrameGraphBuilder &builder) {
        RenderTargetDesc rdesc;
        rdesc.size = builder.getRenderSize();
        rdesc.hasDepthStencilAttachment = true;
        rdesc.numberOfColorAttachments = 1;
        target = builder.createRenderTarget(rdesc);
        blitTarget = builder.createRenderTarget(rdesc);

        builder.read(target);
        builder.read(blitTarget);

        if (!vertexBuffer.assigned) {
            VertexBufferDesc desc;
            desc.size = mesh.vertices.size() * mesh.vertexLayout.getSize();
            vertexBuffer = builder.createVertexBuffer(desc);

            VertexArrayObjectDesc oDesc;
            oDesc.vertexLayout = mesh.vertexLayout;
            vertexArrayObject = builder.createVertexArrayObject(oDesc);

            builder.write(vertexBuffer);
        }
        builder.persist(vertexBuffer);
        builder.persist(vertexArrayObject);

        builder.read(vertexBuffer);
        builder.read(vertexArrayObject);

        if (!pipeline.assigned) {
            RenderPipelineDesc pdesc{};
            pdesc.shaders = {
                    {VERTEX,   compositepass_vs.getShader()},
                    {FRAGMENT, compositepass_fs.getShader()}
            };
            pdesc.bindings = {
                    BIND_TEXTURE_BUFFER,
                    BIND_TEXTURE_BUFFER
            };
            pdesc.primitive = TRIANGLES;
            pdesc.vertexLayout = mesh.vertexLayout;
            pdesc.enableBlending = true;
            pdesc.enableDepthTest = true;
            pdesc.depthTestWrite = true;
            //https://stackoverflow.com/a/16938711
            pdesc.colorBlendSourceMode = SRC_ALPHA;
            pdesc.colorBlendDestinationMode = ONE_MINUS_SRC_ALPHA;
            pdesc.alphaBlendSourceMode = ONE;
            pdesc.alphaBlendDestinationMode = ONE_MINUS_SRC_ALPHA;
            pipeline = builder.createPipeline(pdesc);
        }

        builder.persist(pipeline);
        builder.read(pipeline);

        RenderPassDesc passDesc;
        passDesc.numberOfColorAttachments = 1;
        passDesc.hasDepthStencilAttachment = true;
        pass = builder.createRenderPass(passDesc);

        builder.read(pass);

        screenColor = builder.getSlot(SLOT_SCREEN_COLOR);
        screenDepth = builder.getSlot(SLOT_SCREEN_DEPTH);

        deferredColor = builder.getSlot(SLOT_DEFERRED_COLOR);
        deferredDepth = builder.getSlot(SLOT_DEFERRED_DEPTH);

        forwardColor = builder.getSlot(SLOT_FORWARD_COLOR);
        forwardDepth = builder.getSlot(SLOT_FORWARD_DEPTH);

        builder.write(screenColor);
        builder.write(screenDepth);
        builder.read(deferredColor);
        builder.read(deferredDepth);
        builder.read(forwardColor);
        builder.read(forwardDepth);
    }

    void CompositePass::execute(FrameGraphPassResources &resources) {
        auto &t = resources.get<RenderTarget>(target);
        auto &bt = resources.get<RenderTarget>(blitTarget);

        auto &pip = resources.get<RenderPipeline>(pipeline);
        auto &p = resources.get<RenderPass>(pass);

        auto &vb = resources.get<VertexBuffer>(vertexBuffer);
        auto &vao = resources.get<VertexArrayObject>(vertexArrayObject);

        auto &sColor = resources.get<TextureBuffer>(screenColor);
        auto &sDepth = resources.get<TextureBuffer>(screenDepth);

        auto &dColor = resources.get<TextureBuffer>(deferredColor);
        auto &dDepth = resources.get<TextureBuffer>(deferredDepth);

        auto &fColor = resources.get<TextureBuffer>(forwardColor);
        auto &fDepth = resources.get<TextureBuffer>(forwardDepth);

        if (!quadAllocated) {
            quadAllocated = true;
            auto verts = VertexStream().addVertices(mesh.vertices).getVertexBuffer();
            vb.upload(0,
                      verts.data(),
                      verts.size());
            vao.bindBuffers(vb);
        }

        t.setColorAttachments({sColor});
        t.setDepthStencilAttachment(sDepth);

        bt.setColorAttachments({dColor});
        bt.setDepthStencilAttachment(dDepth);

        t.blitColor(bt, {}, {}, bt.getDescription().size, t.getDescription().size, NEAREST, 0, 0);
        t.blitDepth(bt, {}, {}, bt.getDescription().size, t.getDescription().size);

        bt.setColorAttachments({});
        bt.clearDepthStencilAttachment();

        p.beginRenderPass(t, {}, t.getDescription().size);
        p.bindPipeline(pip);
        p.bindVertexArrayObject(vao);
        p.bindShaderData({fColor, fDepth});

        p.drawArray(RenderPass::DrawCall(0, mesh.vertices.size()));

        p.endRenderPass();

        t.setColorAttachments({});
        t.clearDepthStencilAttachment();
    }

    std::type_index CompositePass::getTypeIndex() const {
        return typeid(CompositePass);
    }
}